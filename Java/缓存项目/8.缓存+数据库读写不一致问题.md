###  											缓存+数据库读写不一致问题

- 1、最初级的缓存+数据库不一致问题解决方案
  - 先删除缓存，然后再修改数据库
- 2、高并发场景下缓存+数据库不一致问题解决方案（数据库没更新完，读请求过来）
  - 先删除缓存，数据库读取更新串行化执行，将数据的唯一标识，操作路由之后，发送到一个jvm内部的队列中，读取和更新位于同一个内存队列，一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行
- 异步串行化读请求超时
  - 更新请求没有执行完成，在超时时间范围内返回数据库旧值
- 读请求去重优化
  - 如果一个读请求过来，发现前面已经有一个读请求和写请求，那么这个请求不需要放入内存队列，只要hang一会可以从缓存读取数据
- 空数据读请求优化
  - 某个数据，数据库中没有，这个读请求不需要放入内存队列，直接controller层返回null（采用flag map，只要数据库有更新操作，flag就有值，只要flag为空就表明数据库中没有数据）
- 缓存维度化
  - 缓存全量更新每次需要更新全部数据，将数据按照不同维度拆分存储，每次更新只需要更新该维度数据，减少网络资源消耗，缓解redis压力
- 缓存数据生产服务的工作流程分析
  - （1）监听多个kafka topic，每个kafka topic对应一个服务（简化一下，监听一个kafka topic）
    （2）如果一个服务发生数据变更，就发送一个消息到kafka topic中
    （3）缓存数据生产服务监听到消息后，发送请求到对应的服务从mysql拉去数据
    （4）缓存数据生产服务拉取到了数据之后，将数据在本地缓存（ehcache本地堆缓存）和redis中写一份
- 缓存清理设置 
  - LRU算法：清除缓存中最少使用的数据 redis.conf中maxmemory配置
  - redis采取的是LRU近似算法，也就是对keys进行采样，然后在采样结果中进行数据清理