### 微服务系统架构设计

- 前端页面
  - 静的部分，直接被动态渲染系统渲染进去了
  - 动的部分，html一到浏览器，直接走js脚本，ajax异步加载
  - 商品详情页，分段存储，ajax异步分屏加载
- 动态渲染系统
  - （1）依赖服务 -> MQ -> 动态渲染服务 -> 多级缓存
    （2）负载均衡 -> 分发层nginx -> 应用层nginx -> 多级缓存
    （3）多级缓存 -> 数据直连服务 
- 并发化
  - 数据同步服务：并发化+合并，将多个变更消息合并在一起，调用依赖服务一次接口获取多个数据，采用多线程并发调用
  - 数据聚合服务：并发化，每次重新聚合数据的时候，对多个原子数据用多线程并发从redis查询
- 高可用设计
  - 多链路降级策略：本机房从集群 -> 主集群 -> 直连
  - 全链路隔离
    - 基于hystrix的依赖调用隔离，限流，熔断，降级
    - 普通服务的多机房容灾冗余部署以及隔离
- redis cluster的问题
  - （1）不好做读写分离，读写请求全部落到主实例上的，如果要扩展写QPS，或者是扩展读QPS，都是需要扩展主实例的数量，从实例就是一个用做热备+高可用
    （2）不好跟nginx+lua直接整合，lua->redis的client api，但是不太支持redis cluster，中间就要走一个中转的java服务
    （3）不好做树状集群结构，比如redis主集群一主三从双机房架构，redis cluster不太好做成那种树状结构
    （4）方便，相当于是上下线节点，集群扩容，运维工作，高可用自动切换，比较方便
- twemproxy+redis去做集群
  - redis部署多个主实例，每个主实例可以挂载一些redis从实例，如果将不同的数据分片，写入不同的redis主实例中，twemproxy这么一个缓存集群的中间件
  - （1）上线下线节点，有一些手工维护集群的成本
    （2）支持redis集群+读写分离，就是最基本的多个redis主实例，twemproxy这个中间件来决定的，java/nginx+lua客户端，是连接twemproxy中间件的。每个redis主实例就挂载了多个redis从实例，高可用->哨兵，redis cluster读写都要落到主实例的限制，你自己可以决定写主，读从，等等
    （3）支持redis cli协议，可以直接跟nginx+lua整合
    （4）可以搭建树状集群结构